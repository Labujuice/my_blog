<!DOCTYPE html><html lang="zh-tw"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Docker 3: use container to compile - Kenny&#x27;s Blog</title><meta name="description" content="Container 到底要怎麼用呢執行指令得到image後，我們可以透過docker run &lt;image name&gt; &lt;CMD&gt; 執行，被開起來的image稱為container，但是按照上面的指令開下去很快就離開了，例如： image run ubuntu echo hi 。 原因是container的存在是需要精神糧食的，必須要有程式不斷在執行或者是背景有個service在運作，而最簡單讓他活在當下的作法就是讓他前景執行終端機 docker run -it ubuntu ，這樣子就會讓這個container一直存在著，可以開另外一個terminal執行 docker ps 應該可以看到他一直在執行中。 因此如果我需要這個container一直在背景活著怎麼做呢？ while [TRUE]; do echo QQ; sleep 1; done這時候每隔一秒鐘就會印一次QQ，藉此讓這個程式一直活著。 這是看到許多網友的作法，但我覺的不太好。直接讓這個container用交互背景模式下去跑 docker run -id ubuntu這時候會回一堆亂數字後就退出，但是利用 docker ps 是可以發現這個container確實在背景執行著。背景執行指令如果要在背景執行的contianer執行一些指令，則是 docker exec &lt;container name&gt; &lt;cmd&gt;離開contianer直接砍掉在背景執行的container等於在前景執行 exit，手法是&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://labujuice.github.io/my_blog/docker-3-shi-yongcontainer.html"><link rel="alternate" type="application/atom+xml" href="https://labujuice.github.io/my_blog/feed.xml"><link rel="alternate" type="application/json" href="https://labujuice.github.io/my_blog/feed.json"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--logo-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--menu-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="https://labujuice.github.io/my_blog/assets/css/style.css?v=a2907e9470c82233cdf1355247791a45"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://labujuice.github.io/my_blog/docker-3-shi-yongcontainer.html"},"headline":"Docker 3: use container to compile","datePublished":"2021-03-04T16:51","dateModified":"2021-03-04T20:11","description":"Container 到底要怎麼用呢執行指令得到image後，我們可以透過docker run &lt;image name&gt; &lt;CMD&gt; 執行，被開起來的image稱為container，但是按照上面的指令開下去很快就離開了，例如： image run ubuntu echo hi 。 原因是container的存在是需要精神糧食的，必須要有程式不斷在執行或者是背景有個service在運作，而最簡單讓他活在當下的作法就是讓他前景執行終端機 docker run -it ubuntu ，這樣子就會讓這個container一直存在著，可以開另外一個terminal執行 docker ps 應該可以看到他一直在執行中。 因此如果我需要這個container一直在背景活著怎麼做呢？ while [TRUE]; do echo QQ; sleep 1; done這時候每隔一秒鐘就會印一次QQ，藉此讓這個程式一直活著。 這是看到許多網友的作法，但我覺的不太好。直接讓這個container用交互背景模式下去跑 docker run -id ubuntu這時候會回一堆亂數字後就退出，但是利用 docker ps 是可以發現這個container確實在背景執行著。背景執行指令如果要在背景執行的contianer執行一些指令，則是 docker exec &lt;container name&gt; &lt;cmd&gt;離開contianer直接砍掉在背景執行的container等於在前景執行 exit，手法是&hellip;","author":{"@type":"Person","name":"Kenny Chan"},"publisher":{"@type":"Organization","name":"Kenny Chan"}}</script></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://labujuice.github.io/my_blog/">Kenny&#x27;s Blog</a><nav class="navbar js-navbar"><button class="navbar__toggle js-toggle" aria-label="Menu" aria-haspopup="true" aria-expanded="false"><span class="navbar__toggle-box"><span class="navbar__toggle-inner">Menu</span></span></button><ul class="navbar__menu"><li><a href="https://labujuice.github.io/my_blog/about-me.html" target="_self">ABOUT</a></li><li class="active-parent has-submenu"><a href="https://labujuice.github.io/my_blog/tags/docker/" target="_self" aria-haspopup="true">Docker</a><ul class="navbar__submenu level-2" aria-hidden="true"><li><a href="https://labujuice.github.io/my_blog/docker-1-installatio.html" target="_self">Docker 1: 安裝</a></li><li><a href="https://labujuice.github.io/my_blog/docker-2-zhuan-xie-dockerfile.html" target="_self">Docker 2: Dockerfile</a></li><li class="active"><a href="https://labujuice.github.io/my_blog/docker-3-shi-yongcontainer.html" target="_self">Docker 3: Compile with container</a></li></ul></li></ul></nav></header><main><article class="post"><div class="hero"><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2021-03-04T16:51">三月 4, 2021</time></div><h1>Docker 3: use container to compile</h1><div class="post__meta post__meta--author"><img src="https://labujuice.github.io/my_blog/media/website/IMG_6244.JPG" loading="eager" alt="Kenny Chan" class="post__author-thumb"> <a href="https://labujuice.github.io/my_blog/authors/kenny-chan/" class="feed__author invert">Kenny Chan</a></div></div></header></div><div class="wrapper post__entry"><h2 id="container-到底要怎麼用呢">Container 到底要怎麼用呢</h2><h3 id="執行指令">執行指令</h3><p>得到image後，我們可以透過<code>docker run &lt;image name&gt; &lt;CMD&gt;</code> 執行，被開起來的image稱為container，但是按照上面的指令開下去很快就離開了，例如： <code>image run ubuntu echo hi</code> 。</p><h3 id="前景執行">前景執行</h3><p>原因是container的存在是需要精神糧食的，必須要有程式不斷在執行或者是背景有個service在運作，而最簡單讓他活在當下的作法就是讓他前景執行終端機 <code>docker run -it ubuntu</code> ，這樣子就會讓這個container一直存在著，可以開另外一個terminal執行 <code>docker ps</code> 應該可以看到他一直在執行中。</p><h3 id="背景執行">背景執行</h3><p>因此如果我需要這個container一直在背景活著怎麼做呢？</p><ol><li>可以寫一個垃圾script讓他一直執行著不會出來，example：<pre><code>while [TRUE]; do echo QQ; sleep 1; done</code></pre>這時候每隔一秒鐘就會印一次QQ，藉此讓這個程式一直活著。 這是看到許多網友的作法，但我覺的不太好。</li><li>直接讓這個container用交互背景模式下去跑<pre><code>docker run -id ubuntu</code></pre>這時候會回一堆亂數字後就退出，但是利用 <code>docker ps</code> 是可以發現這個container確實在背景執行著。</li></ol><h3 id="背景執行指令">背景執行指令</h3><p>如果要在背景執行的contianer執行一些指令，則是</p><pre><code>docker exec &lt;container name&gt; &lt;cmd&gt;</code></pre><h3 id="離開contianer">離開contianer</h3><p>直接砍掉在背景執行的container等於在前景執行 <code>exit</code>，手法是</p><pre><code>docker kill &lt;container name&gt;</code></pre><h2 id="映射資料夾">映射資料夾</h2><p>這功能主要是將電腦內的資料夾掛載入container內，讓container內也可以撈到外面的資料夾，其指令為</p><pre><code>docker run -v &lt;LocalPath&gt;:&lt;ContainerPath&gt; &lt;image&gt; &lt;CMD&gt;</code></pre><p>這邊可以任意找開個資料夾做測試</p><pre><code>cd Desktop
mkdir LayerOne
cd LayerOne
mkdir LayerTwo_1
mkdir LayerTwo_2
mkdir LayerTwo_3

docker run -v $PWD:/home/Desktop -w /home/Desktop -it ubuntu</code></pre><p><code>-w &lt;default path&gt;</code> 進入container的目錄位置。</p><p>進入之後<code>ls</code> 可以發現那三個資料夾出現在container內，接著試試看 <code>rm -r *</code> 可以發現在container內已經把三個資料夾砍掉了，最後<code>exit</code> 退出回到原本電腦目錄中，可以發現那三個資料夾確實也被砍掉了，證實了這個資料夾映射確實是可以雙向共用的。</p><h2 id="範例">範例</h2><p>這邊舉一個範例是透過container進行編譯的動作：</p><pre><code>cd /tmp/
git clone https://github.com/Labujuice/LimitSpeedCalculator
cd LimitSpeedCalculator/Quadrotor/

docker run -v $PWD:/home/workspace -w /home/workspace kennycym/ubuntu_2004_arm_gcc_2018q2 make; ./out</code></pre><p>這個範例將下載下來的專案放入container內編譯之後在裡面執行後退出，另外一種玩法是先進入container之後在自行補上編譯與執行的指令。</p><pre><code>cd /tmp/
git clone https://github.com/Labujuice/LimitSpeedCalculator
cd LimitSpeedCalculator/Quadrotor/

docker run -v $PWD:/home/workspace -w /home/workspace -it kennycym/ubuntu_2004_arm_gcc_2018q2 

make
./out</code></pre><p>可以透過一些 <code>rm</code> <code>make clean</code> 等指令交互做一些比較，應該就是這麼樣一回事了。</p><h2 id="references">References</h2><ol><li><a href="https://docs.docker.com/engine/reference/run/">Docker Docs : Docker run reference</a></li><li><a href="https://docs.docker.com/engine/reference/commandline/exec/">Docker Docs : docker exec</a></li><li><a href="https://newtoypia.blogspot.com/2017/02/docker.html">Docker 新手第二課： 前景/背景/收工休息 圖解狀態轉換</a></li><li><a href="https://www.runoob.com/docker/docker-run-command.html">Docker run 命令</a></li></ol></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on 三月 4, 2021</p><ul class="post__tag"><li><a href="https://labujuice.github.io/my_blog/tags/docker/">Docker</a></li></ul><div class="post__share"></div><div class="post__bio bio"><img class="bio__avatar" src="https://labujuice.github.io/my_blog/media/website/IMG_6244.JPG" loading="lazy" alt="Kenny Chan"><div class="bio__info"><h3 class="bio__name"><a href="https://labujuice.github.io/my_blog/authors/kenny-chan/" class="invert" rel="author">Kenny Chan</a></h3><p>一個常常忘記自己做過什麼的人，所以才要把它們都記下來。</p></div></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-prev"><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://labujuice.github.io/my_blog/assets/svg/svg-map.svg#arrow-prev"/></svg> <a href="https://labujuice.github.io/my_blog/docker-2-zhuan-xie-dockerfile.html" class="invert post__nav-link" rel="prev"><span>Previous</span> Docker 2 撰寫 Dockerfile</a></div></div></nav><div class="post__related related"><div class="wrapper"><h2 class="h5 related__title">You should also read:</h2><article class="related__item"><div class="feed__meta"><time datetime="2021-03-03T09:58" class="feed__date">三月 3, 2021</time></div><h3 class="h1"><a href="https://labujuice.github.io/my_blog/docker-2-zhuan-xie-dockerfile.html" class="invert">Docker 2 撰寫 Dockerfile</a></h3></article><article class="related__item"><div class="feed__meta"><time datetime="2021-03-03T09:47" class="feed__date">三月 3, 2021</time></div><h3 class="h1"><a href="https://labujuice.github.io/my_blog/docker-1-installatio.html" class="invert">Docker 1 安裝</a></h3></article></div></div></main><footer class="footer"><div class="footer__copyright"><p>Powered by <a href="https://getpublii.com" target="_blank" rel="nofollow noopener">Publii</a></p></div><button class="footer__bttop js-footer__bttop" aria-label="Back to top"><svg><title>Back to top</title><use xlink:href="https://labujuice.github.io/my_blog/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 300,
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://labujuice.github.io/my_blog/assets/js/scripts.min.js?v=f4c4d35432d0e17d212f2fae4e0f8247"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>